# Kernel

目录

- [Kernel](#kernel)
  - [获取内核源码及编译](#获取内核源码及编译)
  - [内核开发特点](#内核开发特点)

## 获取内核源码及编译

[官网](https://git.kernel.org/)可以获取源码。这里选择用git获取

```bash
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
```

编译内核前，需要对其进行配置和定制

```bash
make defconfig  # 默认配置
make config     # 使用命令行遍历配置项
make menuconfig # 基于图形界面选择配置
```

配置完毕后，就可以编译内核了。首次编译可能会报错，多是少安装了一些库，百度一下就好了

```bash
make
```

进入漫长的等待...

## 内核开发特点

1. 无libc库或标准头文件：内核不能直接链接使用标准C库。大部分常用的C库函数都在内核中另外实现。比如不能直接使用`printf`，而是应该使用`printk`
2. GNU C：内核开发用到许多gcc提供的语言扩展特性
   1. 内联函数：一般在头文件中定义`static inline xxx`，可以减小递归调用栈。内核中为了类型安全和可读性，优先使用内联函数而不是宏
   2. 内联汇编：gcc支持在C语言中嵌入汇编指令。内核在偏近底层的位置以及对执行时间要求严格的位置，一般使用汇编，其余大部分位置使用C
   3. 分支声明：gcc对于分支选择语句，内建了一条指令用于优化，内核将其封装为`likely`和`unlikely`宏，需要注意他的使用，错误使用会有负优化
3. 没有内存保护机制：用户程序如果非法操作内存，那么内核会发现这个错误，并发送`SIGSEGV`信号，结束进程。但是如果内核自己非法访问内存，那么后果很难控制。内核中发生的内存错误回导致oops（内核中最常出现的一类错误）
4. 不要轻易在内核中使用浮点数
5. 栈容积小且固定：用户程序可以从栈上分配大量空间，因为用户空间的栈比较大，还可以动态增长；但是内核栈的大小随体系结构而变，一般是8KB（32bit）或16KB（64bit）
6. 同步和并发：内核的特性决定了其中很容易出现竞争，必须能够并发访问共享数据，常用的办法是自旋锁和信号量
7. 可移植性：Linux是一个可移植的操作系统，大部分C代码都应该与体系结构无关。诸如保持字节序、64位对齐等准则都有助于提高移植性
